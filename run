#!/usr/bin/env node
/*

Ideal psuedo-code

if dep changes
  - scan file for new deps
    - if dep is not installed, install it, restart()
    - else restart()
  - scan file for removed deps
    - unwatch the removed dep (use refcount)
    - restart()
  - deps that were there last time
    - do nothing

if dep is deleted
  - unwatch it (automatic)
  - unwatch its sub-deps (use refcount)
  - restart()
*/
var path = require('path')
var inside = require('./inside')
var required = require('required')
var refwatch = require('./refwatch')
var watcher = refwatch.watcher
var watch = refwatch.watch
var unwatch = refwatch.unwatch

var root = path.resolve(process.argv[2])
var runner = require('./runner')(process.argv.slice(2))

function l() { console.log.apply(console, arguments) }

// TODO make these arguments to refwatch
watcher
  .on('change', onChange)
  .on('unlink', onUnlink)
  .on('error', onWatcherError)
function onChange(path) {
  l('File', path, 'has been changed')
  // TODO reindex(path)
  runner.restart()
}
// This case only matters when we want to restart; it's okay to overwatch
function onUnlink(path) {
  l('File', path, 'has been removed')
  // TODO unwatch(path)
  // TODO unindex(path)
  runner.restart()
}
function onWatcherError(error) {
  console.error('onWatcherError %s\n', error.stack)
}

watch(root)
return parseAndWatch(root, function() {
  runner.start()
})

// if the parse fails because the package is not installed / doesn't exist,
// handleError tries to install it & restart, or just logs the error.
function parseAndWatch(filename, cb) {
  // TODO clear listeners, clear refcounts
  return required(filename, onDeps)
  function onDeps(err, deps) {
    if (err) return handleError(err, filename)
    watchDepTree(deps)
    return cb && cb()
  }
}
function handleError(err, root) {
  var name = inside(err.message, "'")
  if (name) {
    var filename = err.message.slice(err.message.lastIndexOf(' ')+1)
    l('TODO npm install %s # seen in: %s', name, filename)
    // TODO actually install it, not pretend to
    return setTimeout(function() {
      return parseAndWatch(root)
    }, 2000)
  }
  // it was an unknown kind of error, give up.
  l(err.stack)
}

function isNotCore(dep) { return !dep.core }
// function isPath(dep) { return dep.id[0] === '.' || dep.id[0] === '/' }
// function isNotPath(dep) { return !isPath(dep) }

function watchDepTree(deps, indent) {
  indent = indent || ''
  // console.log('deps', JSON.stringify(deps, null, 2))
  var userland = deps.filter(isNotCore)
  // l(indent + 'userland', JSON.stringify(userland).slice(0, 40))

  userland.map(function(dep) {
    watch(dep.filename)
    watchDepTree(dep.deps, indent + '\t')
  })
  // var js = userland.filter(isPath)
  // var modules = userland.filter(isNotPath)
}
